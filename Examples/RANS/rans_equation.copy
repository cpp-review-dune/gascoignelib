/**
 *
 * Copyright (C) 2004 by the Gascoigne 3D authors
 *
 * This file is part of Gascoigne 3D
 *
 * Gascoigne 3D is free software: you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later
 * version.
 *
 * Gascoigne 3D is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * Please refer to the file LICENSE.TXT for further information
 * on this license.
 *
 **/

//#include "rans_lsqation.h"
#include "filescanner.h"
#include "dataformathandler.h"

/*-----------------------------------------*/

namespace Gascoigne
{
rans_lsq::~rans_lsq()
{
}

/*-----------------------------------------*/

rans_lsq::rans_lsq()
    : LpsEquation(), _visc(0.01), _h(0.0), _rst(symm_mat_2x2::Zero()), _feature_vector(vec13::Zero())
{
}

/*-----------------------------------------*/

rans_lsq::rans_lsq(const ParamFile* pf)
    : rans_base(pf)
{
}

/*-----------------------------------------*/

void point(double h, const FemFunction& U, const Vertex2d& v) const
{
    _h = h;
    mat2x2 nabla_velocity << v11, v12, v21, v22;
    feature_computation(nabla_velocity);
}

/*-----------------------------------------*/

void rans_lsq::lpspoint(double h, const FemFunction& U, const Vertex2d& v) const
{
    double _norm = std::sqrt(U[1].m() * U[1].m() + U[2].m() * U[2].m());
    double val   = 6. * _visc / (h * h) + _norm / h;
    _delta     = _delta0 / val;
    _alpha     = _alpha0 / val;
}

/*-----------------------------------------*/

void rans_lsq::Form(VectorIterator b, const FemFunction& U, const TestFunction& N) const
{
    // Divergence
    b[0] += (U[1].x() + U[2].y()) * N.m();

    for (auto i : {1, 2})
    {
        // Time derivative
        b[i] += (U[i].m() - (*OLD)[i].m()) * N.m() / (GetTimeStep());
        // Pressure
        b[i] -= U[0].m() * N[i];
        // Laplace
        b[i] += _theta * _visc * (U[i].x() * N.x() + U[i].y() * N.y());
        b[i] += (1 - _theta) * _visc * ((*OLD)[i].x() * N.x() + (*OLD)[i].y() * N.y());
        // Convection
        b[i] += _theta * (U[1].m() * U[i].x() + U[2].m() * U[i].y()) * N.m();
        b[i] +=
          (1 - _theta) * ((*OLD)[1].m() * (*OLD)[i].x() + (*OLD)[2].m() * (*OLD)[i].y()) * N.m();
    }
    // RST
    // b[1] += _rst[0] * N.x() + _rst[1] * N.y();
    // b[2] += _rst[1] * N.x() + _rst[2] * N.y();
}

/*-----------------------------------------*/

void rans_lsq::Matrix(EntryMatrix& A, const FemFunction& U, const TestFunction& M,
                      const TestFunction& N) const
{
    // Laplace
    double lp_conv = _visc * (M.x() * N.x() + M.y() * N.y());
    // Convection
    lp_conv += (U[1].m() * M.x() + U[2].m() * M.y()) * N.m();
    lp_conv *= _theta;
    for (auto i : {1, 2})
    {
        // Time derivative
        A(i, i) += M.m() * N.m() / GetTimeStep();
        // Laplace and Convection
        A(i, i) += lp_conv;
        // Divergence
        A(0, i) += M[i] * N.m();
        // Pressure
        A(i, 0) -= N[i] * M.m();
    }
}

/*-----------------------------------------*/

void rans_lsq::StabForm(VectorIterator b, const FemFunction& U, const FemFunction& UP,
                        const TestFunction& N) const
{
    auto beta = U[1].m() * N.x() + U[2].m() * N.y();
    for (auto i : {1, 2})
    {
        b[0] += _alpha * UP[0][i] * N[i];
        b[1] += _delta * beta * (U[1].m() * UP[i].x() + U[2].m() * UP[i].y());
        b[2] += _delta * beta * (U[1].m() * UP[i].x() + U[2].m() * UP[i].y());
    }
}

/*-----------------------------------------*/

void rans_lsq::StabMatrix(EntryMatrix& A, const FemFunction& U, const TestFunction& Np,
                          const TestFunction& Mp) const
{
    A(0, 0) += _alpha * (Mp.x() * Np.x() + Mp.y() * Np.y());
    auto beta_stab =
      _delta * (U[1].m() * Mp.x() + U[2].m() * Mp.y()) * (U[1].m() * Np.x() + U[2].m() * Np.y());
    for (auto i : {1, 2})
        A(i, i) += beta_stab;
}

}  // namespace Gascoigne
